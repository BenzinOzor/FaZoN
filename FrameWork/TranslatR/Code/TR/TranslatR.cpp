#include <functional>
#include <fstream>

#include <FZN/Managers/FazonCore.h>
#include <FZN/Tools/Logging.h>
#include <FZN/Tools/Math.h>
#include <FZN/Tools/Tools.h>
#include <FZN/UI/ImGui.h>

#include "TR/TranslatR.h"

namespace TR
{
	static constexpr uint32_t version_major = 0;
	static constexpr uint32_t version_minor = 0;
	static constexpr uint32_t version_feature = 0;
	static constexpr uint32_t version_bugfix = 0;
	static constexpr bool WIP_version = true;

	inline constexpr ImVec4 darker_red{ 0.25f, 0.05f, 0.05f, 0.4f };

	static const std::string enum_file_message{ "// This file is generated by the TranslatR application. Do not edit it directly or modification will be overwritten!" };

	TranslatR::TranslatR()
	{
		g_pFZN_Core->AddCallback( this, &TranslatR::display, fzn::DataCallbackType::Display );

		auto& oIO = ImGui::GetIO();

		oIO.ConfigWindowsMoveFromTitleBarOnly = true;
		oIO.ConfigFlags |= ImGuiConfigFlags_DockingEnable;
		oIO.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;

		ImGui_fzn::s_ImGuiFormatOptions.m_pFontRegular = oIO.Fonts->AddFontFromFileTTF( DATAPATH( "Display/CascadiaMono.ttf" ), 14.f );
		ImGui_fzn::s_ImGuiFormatOptions.m_pFontBold = oIO.Fonts->AddFontFromFileTTF( DATAPATH( "Display/CascadiaMono-Bold.otf" ), 14.f );
		ImGui_fzn::s_ImGuiFormatOptions.m_pFontItalic = oIO.Fonts->AddFontFromFileTTF( DATAPATH( "Display/CascadiaMono-Italic.otf" ), 14.f );
	}

	TranslatR::~TranslatR()
	{
		g_pFZN_Core->RemoveCallback( this, &TranslatR::display, fzn::DataCallbackType::Display );
	}

	/**
	* @brief Main ImGui display.
	**/
	void TranslatR::display()
	{
		const sf::Vector2u window_size = g_pFZN_WindowMgr->GetWindowSize();

		ImGui::SetNextWindowPos( { 0.f, 0.f } );
		ImGui::SetNextWindowSize( window_size );
		ImGui::PushStyleVar( ImGuiStyleVar_::ImGuiStyleVar_IndentSpacing, 20.f );
		ImGui::PushStyleVar( ImGuiStyleVar_::ImGuiStyleVar_WindowRounding, 0.f );
		ImGui::PushStyleVar( ImGuiStyleVar_::ImGuiStyleVar_WindowBorderSize, 0.f );
		ImGui::PushStyleVar( ImGuiStyleVar_::ImGuiStyleVar_WindowPadding, ImVec2( 0.0f, 0.0f ) );
		ImGui::PushStyleColor( ImGuiCol_WindowBg, ImVec4( 0.10f, 0.16f, 0.22f, 1.f ) );
		ImGui::PushStyleColor( ImGuiCol_CheckMark, ImVec4( 0.f, 1.f, 0.f, 1.f ) );

		// Overriding those so we don't have any alpha trouble when changing the background of the games section
		ImGui::PushStyleColor( ImGuiCol_FrameBg, ImVec4{ 0.13f, 0.23f, 0.36f, 1.f } );
		ImGui::PushStyleColor( ImGuiCol_FrameBgHovered, ImVec4{ 0.16f, 0.33f, 0.53f, 1.f } );
		ImGui::PushStyleColor( ImGuiCol_FrameBgActive, ImVec4{ 0.21f, 0.45f, 0.73f, 1.f } );
		ImGui::PushStyleColor( ImGuiCol_Button, ImVec4{ 0.16f, 0.33f, 0.53f, 1.f } );
		ImGui::PushStyleColor( ImGuiCol_ButtonHovered, ImVec4{ 0.26f, 0.59f, 0.98f, 1.f } );
		ImGui::PushStyleColor( ImGuiCol_ButtonActive, ImVec4{ 0.06f, 0.53f, 0.98f, 1.f } );

		ImGuiWindowFlags window_flags = ImGuiWindowFlags_MenuBar;
		window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
		window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;

		ImGui::Begin( "Splits Manager", nullptr, window_flags );
		ImGui::PopStyleVar( 3 );

		_display_menu_bar();

		if( m_entries.empty() == false )
		{
			_display_languages();
			_display_entries();
		}

		ImGui::End();

		ImGui::PopStyleVar( 1 );
		ImGui::PopStyleColor( 8 );
	}

	/**
	* @brief Display the window menu bar.
	**/
	void TranslatR::_display_menu_bar()
	{
		auto menu_item = [ & ]( const char* _label, bool _disable, std::function< void( void ) > _fct )
			{
				if( _disable )
					ImGui::BeginDisabled();

				if( ImGui::MenuItem( _label ) )
					_fct();

				if( _disable )
					ImGui::EndDisabled();
			};

		if( ImGui::BeginMainMenuBar() )
		{
			if( ImGui::BeginMenu( "File" ) )
			{
				const bool entries_path_invalid = m_entries_path.empty();
				const bool enum_file_path_invalid = m_enum_file_path.empty();
				//const bool no_games = m_splits_mgr.are_there_games() == false;
				if( ImGui::BeginMenu( "Entries List" ) )
				{
					menu_item( "Create...", false, [ & ]() { _create_json(); } );
					ImGui_fzn::simple_tooltip_on_hover( "Close current file and create a new one." );

					menu_item( "Load...", false, [ & ]() { _load_json(); } );
					menu_item( "Save", entries_path_invalid, [ & ]() { _save_json(); } );
					ImGui_fzn::simple_tooltip_on_hover( fzn::Tools::Sprintf( "Loaded file path: %s", m_entries_path.empty() ? "<example path>" : m_entries_path.c_str() ) );

					menu_item( "Save As...", entries_path_invalid, [ & ]() { _save_json_as(); } );

					ImGui::EndMenu();
				}
				if( ImGui::BeginMenu( "Enum File", m_entries.size() > 0 ) )
				{
					menu_item( "Generate", enum_file_path_invalid, [ & ]() { _generate_enum_file(); } );
					ImGui_fzn::simple_tooltip_on_hover( fzn::Tools::Sprintf( "Enum file path: %s", m_enum_file_path.empty() ? "<example path>" : m_enum_file_path.c_str() ) );
					menu_item( "Generate New...", false, [ & ]() { _generate_enum_file_as(); } );
					ImGui::EndMenu();
				}
				if( ImGui::BeginMenu( "TranslatR Project" ) )
				{
					menu_item( "Close", false, [ & ]() {} );
					ImGui::EndMenu();
				}

				ImGui::Separator();
				menu_item( "Options...", false, [ & ]() {} );

				ImGui::EndMenu();
			}

			const std::string version{ fzn::Tools::Sprintf( "Ver. %d.%d.%d.%d%s", version_major, version_minor, version_feature, version_bugfix, WIP_version ? " - WIP" : "" ) };
			const ImVec2 version_size{ ImGui::CalcTextSize( version.c_str() ) };
			const sf::Vector2u window_size{ g_pFZN_WindowMgr->GetWindowSize() };

			ImGui::SameLine( window_size.x - ImGui::CalcTextSize( version.c_str() ).x - 2.f * ImGui::GetStyle().WindowPadding.x );
			ImGui::TextColored( ImGui_fzn::color::light_gray, version.c_str() );

			ImGui::EndMainMenuBar();
		}
	}

	/**
	* @brief Display and manage available languages.
	**/
	void TranslatR::_display_languages()
	{

	}

	static float get_max_entry_width( float _letter_width, const fzn::Localisation::Entries& _entries )
	{
		float max_width{ 0.f };

		for( const fzn::Localisation::Entry& entry : _entries )
		{
			// Approximate text size to be lightweight.
			if( _letter_width * entry.m_name.size() > max_width )
				max_width = _letter_width * entry.m_name.size();
		}

		return max_width;
	}

	/**
	* @brief Display and manage localisation entries.
	**/
	void TranslatR::_display_entries()
	{
		const uint32_t nb_columns{ m_languages.size() + 2 };		// One column per language and two for entries IDs (number) and name (future enum)
		const float letter_width{ ImGui::CalcTextSize( "W" ).x };
		const float first_column_width{ fzn::Math::get_number_of_digits( m_entries.size() ) * letter_width };
		uint32_t entry_id{ 0 };

		ImGui::Button( "Add Language" );
		ImGui::PushStyleColor( ImGuiCol_FrameBg, ImGui_fzn::color::transparent );

		ImGui::BeginChild( "LocEntriesChild", ImVec2{ 0.f, ImGui::GetContentRegionAvail().y } );
		if( ImGui::BeginTable( "LocEntries", nb_columns, ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_RowBg | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY ) )
		{
			ImGui::PushStyleVar( ImGuiStyleVar_FramePadding, ImVec2{ 0.f, 0.f } );
			ImGui::TableSetupColumn( "#", ImGuiTableColumnFlags_WidthFixed, first_column_width );
			ImGui::TableSetupColumn( "Entry", ImGuiTableColumnFlags_WidthFixed, get_max_entry_width( letter_width, m_entries ) );

			for( const std::string& language : m_languages )
				ImGui::TableSetupColumn( language.c_str(), ImGuiTableColumnFlags_WidthFixed, 600.f );

			ImGui::TableSetupScrollFreeze( 2, 1 );
			ImGui::TableHeadersRow();

			StringVector missing_translations;
			missing_translations.reserve( m_languages.size() );
			std::string missing_translations_tooltip;

			for( fzn::Localisation::Entry& entry : m_entries )
			{
				missing_translations.clear();
				missing_translations_tooltip.clear();

				ImGui::PushID( &entry );

				ImGui::TableNextColumn();
				ImGui::AlignTextToFramePadding();
				ImGui::Text( "%d", entry_id );

				ImGui::TableNextColumn();
				ImGui::SetNextItemWidth( ImGui::GetContentRegionAvail().x );
				uint32_t nb_mmissing_translations{ 0 };
				uint8_t translation_id{ 0 };

				// First pass on the translations to determine which languages are missing. It has to be done here so we know if we have to change the entry text color or not.
				for( std::string& translation : entry.m_translations )
				{
					if( translation.empty() )
					{
						ImGui_fzn::simple_tooltip_on_hover( translation );
						missing_translations.push_back( m_languages[ translation_id ] );
						++nb_mmissing_translations;
					}
					++translation_id;
				}

				if( nb_mmissing_translations > 0 )
				{
					ImGui::PushStyleColor( ImGuiCol_Text, ImGui_fzn::color::light_red );
					ImGui::PushFont( ImGui_fzn::s_ImGuiFormatOptions.m_pFontBold );
				}

				ImGui::InputTextWithHint("##EntryName", "<Entry Name>", &entry.m_name );

				if( nb_mmissing_translations > 0 )
				{
					ImGui::PopFont();
					ImGui::PopStyleColor();
				}

				const bool entry_hovered{ ImGui::IsItemHovered() };

				translation_id = 0;
				for( std::string& translation : entry.m_translations )
				{
					ImGui::TableNextColumn();
					ImGui::SetNextItemWidth( ImGui::GetContentRegionAvail().x );

					const bool no_translation{ translation.empty() };

					if( no_translation )
						ImGui::PushFont( ImGui_fzn::s_ImGuiFormatOptions.m_pFontItalic );

					ImGui::InputTextWithHint( fzn::Tools::Sprintf( "##%s_translation_%d", entry.m_name.c_str(), translation_id ).c_str(), "<No Translation>", &translation );

					if( no_translation )
						ImGui::PopFont();
					else
						ImGui_fzn::simple_tooltip_on_hover( translation );

					++translation_id;
				}

				if( missing_translations.empty() == false )
				{
					if( entry_hovered )
					{
						for( const std::string& language : missing_translations )
						{
							fzn::Tools::sprintf_cat( missing_translations_tooltip, "%s%s", missing_translations_tooltip.empty() ? "" : ", ", language.c_str() );
						}

						ImGui::SetTooltip( "%d missing translations: %s", missing_translations.size(), missing_translations_tooltip.c_str() );
					}

					ImGui::GetCurrentTable()->RowBgColor[ 1 ] = ImGui::GetColorU32( darker_red );
				}
				else if( ImGui::TableGetHoveredRow() - 1 == entry_id )
					ImGui::GetCurrentTable()->RowBgColor[ 1 ] = ImGui::GetColorU32( ImGui::GetStyleColorVec4( ImGuiCol_Header ) );

				++entry_id;
				ImGui::PopID();
			}

			ImGui::PopStyleVar();
			ImGui::EndTable();
		}

		ImGui::EndChild();
		ImGui::PopStyleColor();
	}

	void TranslatR::_create_json()
	{

	}

	void TranslatR::_save_json()
	{
		if( m_entries_path.empty() )
			return;

		auto file = std::ofstream{ m_entries_path };
		auto root = Json::Value{};

		Json::StyledWriter json_writer;

		_write_languages( root );
		_write_entries( root );
		file << json_writer.write( root );
	}

	void TranslatR::_save_json_as()
	{
		std::string new_path = fzn::Tools::save_file_as(	"(*.json) Localisation Entries List\0*.json\0"
															"(*.*) All files \0*.*\0",
															".json" );

		if( new_path.empty() )
			return;

		m_entries_path = new_path;
		_save_json();
	}

	void TranslatR::_load_json()
	{
		m_entries_path = fzn::Tools::open_file(		"(*.json) Localisation Entries List\0*.json\0"
													"(*.*) All files \0*.*\0" );

		fzn::Localisation::Manager::load_entries( m_entries_path, m_entries, m_languages );
	}

	void TranslatR::_write_languages( Json::Value& _root )
	{
		// "available_languages" : ["english","french","spanish"],

		for( uint32_t language_id{ 0 }; language_id < m_languages.size(); ++language_id )
		{
			_root[ "available_languages" ][ language_id ] = m_languages[ language_id ].c_str();
		}
	}

	void TranslatR::_write_entries( Json::Value& _root )
	{
		/*{
			"name" : "yes",
			"translations":
			[
				["english","yes"],
				["french","oui"],
				["spanish","si"]
			]
		},*/

		for( uint32_t entry_index{ 0 }; entry_index < m_entries.size(); ++entry_index )
		{
			const fzn::Localisation::Entry& entry{ m_entries[ entry_index ] };
			Json::Value json_entry{};

			json_entry[ "name" ] = entry.m_name.c_str();

			uint32_t translation_id{ 0 };
			for( uint32_t language_id{ 0 }; language_id < entry.m_translations.size(); ++language_id )
			{
				const std::string& translation{ entry.m_translations[ language_id ] };

				if( translation.empty() )
					continue;

				json_entry[ "translations" ][ translation_id ][ 0 ] = m_languages[ language_id ].c_str();
				json_entry[ "translations" ][ translation_id ][ 1 ] = translation.c_str();
				++translation_id;
			}

			_root[ "entries" ][ entry_index ] = json_entry;
		}
	}

	void TranslatR::_generate_enum_file()
	{
		if( m_enum_file_path.empty() || m_entries.empty() )
			return;

		std::ofstream output( m_enum_file_path );

		output << "#pragma once\n\n" << enum_file_message << "\n\nenum class LocID\n{\n";

		for( const fzn::Localisation::Entry& entry : m_entries )
		{
			output << "\t" << entry.m_name << ",";

			if( entry.m_translations.front().empty() == false )
				output << "\t\t// " << entry.m_translations.front() << std::endl;
			else
				output << std::endl;
		}

		output << "\tCOUNT\n};\n";

		output.close();
	}

	void TranslatR::_generate_enum_file_as()
	{
		std::string new_path = fzn::Tools::save_file_as(	"(*.h) Header File\0*.h\0"
															"(*.*) All files \0*.*\0",
															".h" );

		if( new_path.empty() )
			return;

		m_enum_file_path = new_path;
		_generate_enum_file();
	}

} // namespace TR