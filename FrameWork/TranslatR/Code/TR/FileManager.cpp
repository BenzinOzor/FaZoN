#include <FZN/Tools/Tools.h>

#include "FileManager.h"


namespace TR
{
	static const std::string enum_file_message{ "// This file is generated by the TranslatR application. Do not edit it directly or modification will be overwritten!" };


	/**
	* @brief Manage the File Manager part of the menu bar in the interface.
	**/
	void FileManager::display_menu_bar_items( fzn::Localisation::LocalisationData& _loc_data )
	{
		const bool entries_path_valid = m_entries_path.size() > 0;
		const bool enum_file_path_valid = m_enum_file_path.size() > 0;
		const bool has_entries = _loc_data.m_entries.size() > 0;

		if( ImGui::BeginMenu( "File" ) )
		{
			//const bool no_games = m_splits_mgr.are_there_games() == false;
			if( ImGui::BeginMenu( "Entries List" ) )
			{
				if( ImGui::MenuItem( "Create...", nullptr, false ) ) {}
				ImGui_fzn::simple_tooltip_on_hover( "Close current file and create a new one." );

				if( ImGui::MenuItem( "Open..." ) )
					open_entries_file( _loc_data );

				if( ImGui::MenuItem( "Save", nullptr, false, entries_path_valid ) )
					save_entries( _loc_data );
				ImGui_fzn::simple_tooltip_on_hover( "Loaded file path: %s", m_entries_path.c_str() );

				if( ImGui::MenuItem( "Save As...", nullptr, false, has_entries ) )
					save_entries_as( _loc_data );

				ImGui::EndMenu();
			}
			if( ImGui::BeginMenu( "Enum File", has_entries ) )
			{
				if( ImGui::MenuItem( "Generate", nullptr, false, enum_file_path_valid ) )
					generate_enum_file( _loc_data );
				ImGui_fzn::simple_tooltip_on_hover( "Enum file path: %s", m_enum_file_path.c_str() );

				if( ImGui::MenuItem( "Generate New", nullptr, false, has_entries ) )
					generate_enum_file_as( _loc_data );
				ImGui::EndMenu();
			}
			if( ImGui::BeginMenu( "TranslatR Project" ) )
			{
				if( ImGui::MenuItem( "Close", nullptr, false ) ) {}
				ImGui::EndMenu();
			}

			ImGui::EndMenu();
		}
	}

	void FileManager::open_entries_file( fzn::Localisation::LocalisationData& _loc_data )
	{
		m_entries_path = fzn::Tools::open_file( "(*.json) Localisation Entries List\0*.json\0"
			"(*.*) All files \0*.*\0" );

		fzn::Localisation::Manager::load_entries( m_entries_path, _loc_data );
	}

	void FileManager::save_entries( fzn::Localisation::LocalisationData& _loc_data )
	{
		if( m_entries_path.empty() )
			return;

		auto file = std::ofstream{ m_entries_path };
		auto root = Json::Value{};

		Json::StyledWriter json_writer;

		_write_languages( root, _loc_data );
		_write_entries( root, _loc_data );
		file << json_writer.write( root );
	}

	void FileManager::save_entries_as( fzn::Localisation::LocalisationData& _loc_data )
	{
		std::string new_path = fzn::Tools::save_file_as( "(*.json) Localisation Entries List\0*.json\0"
			"(*.*) All files \0*.*\0",
			".json" );

		if( new_path.empty() )
			return;

		m_entries_path = new_path;
		save_entries( _loc_data );
	}

	void FileManager::generate_enum_file( fzn::Localisation::LocalisationData& _loc_data )
	{
		if( m_enum_file_path.empty() || _loc_data.m_entries.empty() )
			return;

		std::ofstream output( m_enum_file_path );

		output << "#pragma once\n\n" << enum_file_message << "\n\nenum class LocID\n{\n";

		for( const fzn::Localisation::Entry& entry : _loc_data.m_entries )
		{
			output << "\t" << entry.m_name << ",";

			if( entry.m_translations.front().empty() == false )
				output << "\t\t// " << entry.m_translations.front() << std::endl;
			else
				output << std::endl;
		}

		output << "\tCOUNT\n};\n";

		output.close();
	}

	void FileManager::generate_enum_file_as( fzn::Localisation::LocalisationData& _loc_data )
	{
		std::string new_path = fzn::Tools::save_file_as( "(*.h) Header File\0*.h\0"
			"(*.*) All files \0*.*\0",
			".h" );

		if( new_path.empty() )
			return;

		m_enum_file_path = new_path;
		generate_enum_file( _loc_data );
	}

	void FileManager::_write_languages( Json::Value& _root, fzn::Localisation::LocalisationData& _loc_data )
	{
		// "available_languages" : ["english","french","spanish"],

		for( uint32_t language_id{ 0 }; language_id < _loc_data.m_languages.size(); ++language_id )
		{
			_root[ "available_languages" ][ language_id ] = _loc_data.m_languages[ language_id ].c_str();
		}
	}

	void FileManager::_write_entries( Json::Value& _root, fzn::Localisation::LocalisationData& _loc_data )
	{
		/*{
			"name" : "yes",
			"translations":
			[
				["english","yes"],
				["french","oui"],
				["spanish","si"]
			]
		},*/

		for( uint32_t entry_index{ 0 }; entry_index < _loc_data.m_entries.size(); ++entry_index )
		{
			const fzn::Localisation::Entry& entry{ _loc_data.m_entries[ entry_index ] };
			Json::Value json_entry{};

			json_entry[ "name" ] = entry.m_name.c_str();

			uint32_t translation_id{ 0 };
			for( uint32_t language_id{ 0 }; language_id < entry.m_translations.size(); ++language_id )
			{
				const std::string& translation{ entry.m_translations[ language_id ] };

				if( translation.empty() )
					continue;

				json_entry[ "translations" ][ translation_id ][ 0 ] = _loc_data.m_languages[ language_id ].c_str();
				json_entry[ "translations" ][ translation_id ][ 1 ] = translation.c_str();
				++translation_id;
			}

			_root[ "entries" ][ entry_index ] = json_entry;
		}
	}
}
