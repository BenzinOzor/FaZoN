#include <algorithm>

#include <FZN/Managers/FazonCore.h>
#include <FZN/Tools/Tools.h>
#include <FZN/Tools/Event.h>

#include "TR/FileManager.h"


namespace TR
{
	static const std::string recent_paths_file{ "recent_paths.json" };
	static const std::string enum_file_message{ "// This file is generated by the TranslatR application. Do not edit it directly or modification will be overwritten!" };


	/************************************************************************
	* INTERFACE
	************************************************************************/

	FileManager::FileManager()
	{
		g_pFZN_Core->AddCallback( this, &FileManager::on_event, fzn::DataCallbackType::Event );

		_load_recent_paths();
	}

	FileManager::~FileManager()
	{
		g_pFZN_Core->RemoveCallback( this, &FileManager::on_event, fzn::DataCallbackType::Event );
	}

	/**
	* @brief Event handling.
	**/
	void FileManager::on_event()
	{
		sf::Event sf_event = g_pFZN_WindowMgr->GetWindowEvent();

		switch( sf_event.type )
		{
			case sf::Event::Closed:
			{
				_save_recent_paths();
				return;
			};
		};
	}

	/**
	* @brief Manage the File Manager part of the menu bar in the interface.
	* @param [in,out] _loc_data The entries and languages of the current project.
	**/
	void FileManager::display_menu_bar_items( fzn::Localisation::LocalisationData& _loc_data )
	{
		const bool project_path_valid = m_project.m_project_path.size() > 0;
		const bool entries_path_valid = m_project.m_entries_path.size() > 0;
		const bool enum_file_path_valid = m_project.m_enum_file_path.size() > 0;
		const bool has_entries = _loc_data.has_entries();

		if( ImGui::BeginMenu( "File" ) )
		{
			if( ImGui::BeginMenu( "TranslatR Project" ) )
			{
				if( ImGui::MenuItem( "Open..." ) )
					_open_project_file( _loc_data );

				if( ImGui::BeginMenu( "Open Recent", m_recent_paths[ FileType::project ].size() > 0 ) )
				{
					_display_recent_paths( FileType::project, _loc_data );
					ImGui::EndMenu();
				}

				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_green, "Save", {}, false, project_path_valid ) )
					_save_project();
				ImGui_fzn::simple_tooltip_on_hover( "Opened project path: %s", m_project.m_project_path.c_str() );

				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_green, "Save As...", {}, false, has_entries ) )
					_save_project_as();

				ImGui::Separator();
				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_red, "Close", {}, false, project_path_valid ) )
					_close_project( _loc_data );

				ImGui::EndMenu();
			}

			if( ImGui::BeginMenu( "Entries List" ) )
			{
				if( ImGui::MenuItem( "Open..." ) )
					_open_entries_file( _loc_data );

				if( ImGui::BeginMenu( "Open Recent", m_recent_paths[ FileType::entries ].size() > 0 ) )
				{
					_display_recent_paths( FileType::entries, _loc_data );
					ImGui::EndMenu();
				}

				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_green, "Save", {}, false, entries_path_valid ) )
					_save_entries( _loc_data );
				ImGui_fzn::simple_tooltip_on_hover( "Opened file path: %s", m_project.m_entries_path.c_str() );

				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_green, "Save As...", {}, false, has_entries ) )
					_save_entries_as( _loc_data );

				ImGui::Separator();
				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_red, "Close", {}, false, has_entries ) )
					_close_entries( _loc_data );

				ImGui::EndMenu();
			}

			if( ImGui::BeginMenu( "Enum File", has_entries ) )
			{
				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_green, "Generate", {}, false, enum_file_path_valid ) )
					_generate_enum_file( _loc_data );
				ImGui_fzn::simple_tooltip_on_hover( "Enum file path: %s", m_project.m_enum_file_path.c_str() );

				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_green, "Generate New", {}, false, has_entries ) )
					_generate_enum_file_as( _loc_data );

				if( ImGui::BeginMenu( "Generate From Recent Path", m_recent_paths[ FileType::enum_file ].size() > 0 ) )
				{
					_display_recent_paths( FileType::enum_file, _loc_data );
					ImGui::EndMenu();
				}

				ImGui::EndMenu();
			}

			ImGui::EndMenu();
		}
	}


	/************************************************************************
	* ENTRIES
	************************************************************************/

	/**
	* @brief Show an open file dialog to select the entries file and fill the given localisation data with it.
	* @param [out] _loc_data The localisation data to be filled.
	**/
	void FileManager::_open_entries_file( fzn::Localisation::LocalisationData& _loc_data )
	{
		const std::string path = fzn::Tools::open_file( "(*.json) Localisation Entries List\0*.json\0"
			"(*.*) All files \0*.*\0" );

		if( path.empty() )
			return;

		_open_entries_file( path, _loc_data );
		_add_recent_path( FileType::entries, path );
	}

	/**
	* @brief Show an open file dialog to select the entries file and fill the given localisation data with it.
	* @param _path The path to the entries file.
	* @param [out] _loc_data The localisation data to be filled.
	**/
	void FileManager::_open_entries_file( std::string_view _path, fzn::Localisation::LocalisationData& _loc_data )
	{
		m_project.m_entries_path = _path;
		fzn::Localisation::Manager::load_entries( m_project.m_entries_path, _loc_data );
	}

	/**
	* @brief Save the given localisation data to the previously selected path.
	* @param [out] _loc_data The localisation data to be saved.
	**/
	void FileManager::_save_entries( fzn::Localisation::LocalisationData& _loc_data )
	{
		if( m_project.m_entries_path.empty() )
			return;

		auto file = std::ofstream{ m_project.m_entries_path };
		auto root = Json::Value{};

		Json::StyledWriter json_writer;

		_write_languages( root, _loc_data );
		_write_entries( root, _loc_data );
		file << json_writer.write( root );

		_add_recent_path( FileType::entries, m_project.m_entries_path );
	}

	/**
	* @brief Show a save file dialog to select where to save the given localisation data.
	* @param [out] _loc_data The localisation data to be saved.
	**/
	void FileManager::_save_entries_as( fzn::Localisation::LocalisationData& _loc_data )
	{
		std::string new_path = fzn::Tools::save_file_as( "(*.json) Localisation Entries List\0*.json\0"
			"(*.*) All files \0*.*\0",
			".json" );

		if( new_path.empty() )
			return;

		m_project.m_entries_path = new_path;
		_save_entries( _loc_data );
	}

	/**
	* @brief Write the languages section of the given localisation data in the given json root.
	* @param [in,out] _root The json root to fill with the data.
	* @param _loc_data The localisation data to use.
	**/
	void FileManager::_write_languages( Json::Value& _root, const fzn::Localisation::LocalisationData& _loc_data ) const
	{
		// "available_languages" : ["english","french","spanish"],

		for( uint32_t language_id{ 0 }; language_id < _loc_data.m_languages.size(); ++language_id )
		{
			_root[ "available_languages" ][ language_id ] = _loc_data.m_languages[ language_id ].c_str();
		}
	}

	/**
	* @brief Write the entries section of the given localisation data in the given json root.
	* @param [in,out] _root The json root to fill with the data.
	* @param _loc_data The localisation data to use.
	**/
	void FileManager::_write_entries( Json::Value& _root, const fzn::Localisation::LocalisationData& _loc_data ) const
	{
		/*{
			"name" : "yes",
			"translations":
			[
				["english","yes"],
				["french","oui"],
				["spanish","si"]
			]
		},*/

		for( uint32_t entry_index{ 0 }; entry_index < _loc_data.m_entries.size(); ++entry_index )
		{
			const fzn::Localisation::Entry& entry{ _loc_data.m_entries[ entry_index ] };
			Json::Value json_entry{};

			json_entry[ "name" ] = entry.m_name.c_str();

			uint32_t translation_id{ 0 };
			for( uint32_t language_id{ 0 }; language_id < entry.m_translations.size(); ++language_id )
			{
				const std::string& translation{ entry.m_translations[ language_id ] };

				if( translation.empty() )
					continue;

				json_entry[ "translations" ][ translation_id ][ 0 ] = _loc_data.m_languages[ language_id ].c_str();
				json_entry[ "translations" ][ translation_id ][ 1 ] = translation.c_str();
				++translation_id;
			}

			_root[ "entries" ][ entry_index ] = json_entry;
		}
	}

	/**
	* @brief Close the current entries file, clearing all entries and the path to their file.
	* @param [out] _loc_data The localisation data to be cleared.
	**/
	void FileManager::_close_entries( fzn::Localisation::LocalisationData& _loc_data )
	{
		_loc_data.clear();
		m_project.m_entries_path.clear();
	}


	/************************************************************************
	* ENUM FILE
	************************************************************************/

	/**
	* @brief Generate the enum file using the given localisation data to the previously selected path.
	* @param [out] _loc_data The localisation data to be used.
	**/
	void FileManager::_generate_enum_file( fzn::Localisation::LocalisationData& _loc_data )
	{
		if( m_project.m_enum_file_path.empty() || _loc_data.m_entries.empty() )
			return;

		std::ofstream output( m_project.m_enum_file_path );

		output << "#pragma once\n\n" << enum_file_message << "\n\nenum class LocID\n{\n";

		for( const fzn::Localisation::Entry& entry : _loc_data.m_entries )
		{
			output << "\t" << entry.m_name << ",";

			if( entry.m_translations.front().empty() == false )
				output << "\t\t// " << entry.m_translations.front() << std::endl;
			else
				output << std::endl;
		}

		output << "\tCOUNT\n};\n";

		output.close();
		_add_recent_path( FileType::enum_file, m_project.m_enum_file_path );
	}

	/**
	* @brief Show a fave ile dialog to select where to generate the enum file using the given localisation data.
	* @param [out] _loc_data The localisation data to be used.
	**/
	void FileManager::_generate_enum_file_as( fzn::Localisation::LocalisationData& _loc_data )
	{
		std::string path = fzn::Tools::save_file_as( "(*.h) Header File\0*.h\0"
			"(*.*) All files \0*.*\0",
			".h" );

		if( path.empty() )
			return;

		_generate_enum_file_as( path, _loc_data );
		_add_recent_path( FileType::enum_file, path );
	}


	void FileManager::_generate_enum_file_as( std::string_view _path, fzn::Localisation::LocalisationData& _loc_data )
	{
		m_project.m_enum_file_path = _path;
		_generate_enum_file( _loc_data );
	}

	/************************************************************************
	* PROJECT
	************************************************************************/

	/**
	* @brief Show an open file dialog to select the project file and load the corresponding entries file to fill the given localisation data with it.
	* @param [out] _loc_data The localisation data to be filled.
	**/
	void FileManager::_open_project_file( fzn::Localisation::LocalisationData& _loc_data )
	{
		const std::string path = fzn::Tools::open_file( "(*.trproj) TranslatR Project\0*.trproj\0"
			"(*.*) All files \0*.*\0" );

		_open_project_file( path, _loc_data );
		_add_recent_path( FileType::project, path );
	}

	/**
	* @brief Show an open file dialog to select the project file and load the corresponding entries file to fill the given localisation data with it.
	* @param _path The path to the project file.
	* @param [out] _loc_data The localisation data to be filled.
	**/
	void FileManager::_open_project_file( std::string_view _path, fzn::Localisation::LocalisationData& _loc_data )
	{
		auto file = std::ifstream{ _path.data() };

		if( file.is_open() == false )
			return;

		_close_project( _loc_data );

		auto root = Json::Value{};

		file >> root;

		m_project.m_project_path = _path;
		m_project.m_entries_path = root[ "entries_path" ].asString();
		m_project.m_enum_file_path = root[ "enum_file_path" ].asString();

		fzn::Localisation::Manager::load_entries( m_project.m_entries_path, _loc_data );
	}

	/**
	* @brief Save the current project to the previously selected path.
	**/
	void FileManager::_save_project()
	{
		if( m_project.m_project_path.empty() )
			return;

		auto file = std::ofstream{ m_project.m_project_path };
		auto root = Json::Value{};
		Json::StreamWriterBuilder writer_builder;

		writer_builder.settings_[ "emitUTF8" ] = true;
		std::unique_ptr<Json::StreamWriter> writer( writer_builder.newStreamWriter() );

		root[ "entries_path" ] = m_project.m_entries_path.c_str();
		root[ "enum_file_path" ] = m_project.m_enum_file_path.c_str();

		writer->write( root, &file );
		_add_recent_path( FileType::project, m_project.m_project_path );
	}

	/**
	* @brief Show a save file dialog to select where to save the current project.
	**/
	void FileManager::_save_project_as()
	{
		std::string new_path = fzn::Tools::save_file_as( "(*.trproj) TranslatR Project\0*.trproj\0"
			"(*.*) All files \0*.*\0",
			".trproj" );

		if( new_path.empty() )
			return;

		m_project.m_project_path = new_path;
		_save_project();
	}

	/**
	* @brief Close the current project, clearing all save paths.
	* @param [out] _loc_data The localisation data to be cleared.
	**/
	void FileManager::_close_project( fzn::Localisation::LocalisationData& _loc_data )
	{
		m_project.clear();
		_loc_data.clear();
	}


	/************************************************************************
	* RECENT PATHS
	************************************************************************/

	/**
	* @brief Add a path to the history.
	* @param _file_type The file type of the path.
	* @param _path The path to add.
	**/
	void FileManager::_add_recent_path( FileType _file_type, std::string_view _path )
	{
		if( _file_type >= FileType::COUNT || _path.empty() )
			return;

		if( auto it_path = std::ranges::find( m_recent_paths[ _file_type ], _path ); it_path != m_recent_paths[ _file_type ].end() )
			m_recent_paths[ _file_type ].erase( it_path );

		m_recent_paths[ _file_type ].push_front( _path.data() );

		if( m_recent_paths[ _file_type ].size() > m_max_recent_paths )
			m_recent_paths[ _file_type ].pop_back();

		_save_recent_paths();
	}

	/**
	* @brief Save the recent paths to the file.
	**/
	void FileManager::_save_recent_paths() const
	{
		auto file = std::ofstream{ g_pFZN_Core->GetSaveFolderPath() + "/" + recent_paths_file };
		auto root = Json::Value{};
		Json::StreamWriterBuilder writer_builder;

		writer_builder.settings_[ "emitUTF8" ] = true;
		std::unique_ptr<Json::StreamWriter> writer( writer_builder.newStreamWriter() );

		auto save_file_type_path = [&root]( const char* _file_type, const PathDeque& _deque )
			{
				for( uint32_t path{ 0 }; path < _deque.size(); ++path )
				{
					root[ _file_type ][ path ] = _deque[ path ].c_str();
				}
			};

		save_file_type_path( "projects", m_recent_paths[ FileType::project ] );
		save_file_type_path( "entries", m_recent_paths[ FileType::entries ] );
		save_file_type_path( "enum_files", m_recent_paths[ FileType::enum_file ] );

		writer->write( root, &file );
	}

	/**
	* @brief Open the recent paths file to retrieve them.
	**/
	void FileManager::_load_recent_paths()
	{
		auto file = std::ifstream{ g_pFZN_Core->GetSaveFolderPath() + "/" + recent_paths_file };

		if( file.is_open() == false )
			return;

		auto root = Json::Value{};

		file >> root;

		auto add_recent_paths = [ &root ]( const char* _file_type, PathDeque& _deque )
			{
				if( root[ _file_type ].isNull() )
					return;

				Json::Value& history = root[ _file_type ];
				for( Json::Value::iterator it_path = history.begin(); it_path != history.end(); ++it_path )
				{
					const Json::Value& path = *it_path;

					_deque.push_front( path.asString() );
				}
			};

		add_recent_paths( "projects", m_recent_paths[ FileType::project ] );
		add_recent_paths( "entries", m_recent_paths[ FileType::entries ] );
		add_recent_paths( "enum_files", m_recent_paths[ FileType::enum_file ] );
	}

	/**
	* @brief Remove a path from its corresponding deque.
	* @param _file_type The file type of the path.
	* @param _path_id The id of the path in the deque.
	**/
	void FileManager::_remove_recent_path( FileType _file_type, uint32_t _path_id )
	{
		if( _file_type >= FileType::COUNT || _path_id >= m_recent_paths[ _file_type ].size() )
			return;

		m_recent_paths[ _file_type ].erase( m_recent_paths[ _file_type ].begin() + _path_id );
		_save_recent_paths();
	}

	/**
	* @brief Remove all paths from history.
	* @param _type_to_clear The type of file that needs clearing. COUNT will clear everything.
	**/
	void FileManager::_clear_history( FileType _type_to_clear )
	{
		if( _type_to_clear >= FileType::COUNT )
		{
			m_recent_paths[ FileType::project ].clear();
			m_recent_paths[ FileType::entries ].clear();
			m_recent_paths[ FileType::enum_file ].clear();
			_save_recent_paths();
			return;
		}

		m_recent_paths[ _type_to_clear ].clear();
		_save_recent_paths();
	}

	/**
	* @brief Generic function that display recent paths of a given type and manage them.
	* @param _file_type The type of recent paths to display.
	* @param _loc_data The localisation data to manage.
	**/
	void FileManager::_display_recent_paths( FileType _file_type, fzn::Localisation::LocalisationData& _loc_data )
	{
		if( _file_type >= FileType::COUNT )
			return;

		int path_id_to_remove{ -1 };

		for( uint32_t path_id{ 0 }; path_id < m_recent_paths[ _file_type ].size(); ++path_id )
		{
			const std::string path{ m_recent_paths[ _file_type ][ path_id ] };
			ImGui::PushID( path.c_str() );

			ImGui::SetNextItemAllowOverlap();
			if( ImGui::MenuItem( path.c_str() ) )
			{
				switch( _file_type )
				{
					case TR::FileManager::project:
					{
						_open_project_file( path, _loc_data );
						break;
					}
					case TR::FileManager::entries:
					{
						_open_entries_file( path, _loc_data );
						break;
					}
					case TR::FileManager::enum_file:
					{
						_generate_enum_file_as( path, _loc_data );
						break;
					}
					case TR::FileManager::COUNT:
					default:
						break;
				}

				_add_recent_path( _file_type, path );		// Adding the path will remove it from its previous slot and put it at the top of the deque.
			}

			ImGui::SameLine();
			if( ImGui::SmallButton( "x" ) )
				path_id_to_remove = path_id;

			ImGui::PopID();
		}

		if( path_id_to_remove >= 0 )
			_remove_recent_path( _file_type, path_id_to_remove );

		ImGui::Separator();
		if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_red, "Clear All" ) )
			_clear_history( _file_type );
	}
}
