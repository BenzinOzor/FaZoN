#include <FZN/Managers/FazonCore.h>
#include <FZN/Tools/Tools.h>
#include <FZN/Tools/Event.h>

#include "TR/FileManager.h"
#include "TR/Event.h"


namespace TR
{
	static const std::string enum_file_message{ "// This file is generated by the TranslatR application. Do not edit it directly or modification will be overwritten!" };


	/************************************************************************
	* INTERFACE
	************************************************************************/

	/**
	* @brief Manage the File Manager part of the menu bar in the interface.
	* @param [in,out] _loc_data The entries and languages of the current project.
	**/
	void FileManager::display_menu_bar_items( fzn::Localisation::LocalisationData& _loc_data )
	{
		const bool project_path_valid = m_project.m_project_path.size() > 0;
		const bool entries_path_valid = m_project.m_entries_path.size() > 0;
		const bool enum_file_path_valid = m_project.m_enum_file_path.size() > 0;
		const bool has_entries = _loc_data.has_entries();

		if( ImGui::BeginMenu( "File" ) )
		{
			if( ImGui::BeginMenu( "Entries List" ) )
			{
				if( ImGui::MenuItem( "Open..." ) )
					_open_entries_file( _loc_data );

				if( ImGui::MenuItem( "Save", nullptr, false, entries_path_valid ) )
					_save_entries( _loc_data );
				ImGui_fzn::simple_tooltip_on_hover( "Opened file path: %s", m_project.m_entries_path.c_str() );

				if( ImGui::MenuItem( "Save As...", nullptr, false, has_entries ) )
					_save_entries_as( _loc_data );

				ImGui::Separator();
				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_red, "Close", {}, false, has_entries ) )
					_close_entries( _loc_data );

				ImGui::EndMenu();
			}
			if( ImGui::BeginMenu( "Enum File", has_entries ) )
			{
				if( ImGui::MenuItem( "Generate", nullptr, false, enum_file_path_valid ) )
					_generate_enum_file( _loc_data );
				ImGui_fzn::simple_tooltip_on_hover( "Enum file path: %s", m_project.m_enum_file_path.c_str() );

				if( ImGui::MenuItem( "Generate New", nullptr, false, has_entries ) )
					_generate_enum_file_as( _loc_data );
				ImGui::EndMenu();
			}
			if( ImGui::BeginMenu( "TranslatR Project" ) )
			{
				if( ImGui::MenuItem( "Open..." ) )
					_open_project_file( _loc_data );

				if( ImGui::MenuItem( "Save", nullptr, false, project_path_valid ) )
					_save_project();
				ImGui_fzn::simple_tooltip_on_hover( "Opened project path: %s", m_project.m_project_path.c_str() );

				if( ImGui::MenuItem( "Save As...", nullptr, false, has_entries ) )
					_save_project_as();

				ImGui::Separator();
				if( ImGui_fzn::colored_menu_item( ImGui_fzn::color::dark_red, "Close" ) )
					_close_project( _loc_data );

				ImGui::EndMenu();
			}

			ImGui::EndMenu();
		}
	}


	/************************************************************************
	* ENTRIES
	************************************************************************/

	/**
	* @brief Show an open file dialog to select the entries file and fill the given localisation data with it.
	* @param [out] _loc_data The localisation data to be filled.
	**/
	void FileManager::_open_entries_file( fzn::Localisation::LocalisationData& _loc_data )
	{
		m_project.m_entries_path = fzn::Tools::open_file( "(*.json) Localisation Entries List\0*.json\0"
			"(*.*) All files \0*.*\0" );

		fzn::Localisation::Manager::load_entries( m_project.m_entries_path, _loc_data );
	}

	/**
	* @brief Save the given localisation data to the previously selected path.
	* @param [out] _loc_data The localisation data to be saved.
	**/
	void FileManager::_save_entries( fzn::Localisation::LocalisationData& _loc_data ) const
	{
		if( m_project.m_entries_path.empty() )
			return;

		auto file = std::ofstream{ m_project.m_entries_path };
		auto root = Json::Value{};

		Json::StyledWriter json_writer;

		_write_languages( root, _loc_data );
		_write_entries( root, _loc_data );
		file << json_writer.write( root );
	}

	/**
	* @brief Show a save file dialog to select where to save the given localisation data.
	* @param [out] _loc_data The localisation data to be saved.
	**/
	void FileManager::_save_entries_as( fzn::Localisation::LocalisationData& _loc_data )
	{
		std::string new_path = fzn::Tools::save_file_as( "(*.json) Localisation Entries List\0*.json\0"
			"(*.*) All files \0*.*\0",
			".json" );

		if( new_path.empty() )
			return;

		m_project.m_entries_path = new_path;
		_save_entries( _loc_data );
	}

	/**
	* @brief Write the languages section of the given localisation data in the given json root.
	* @param [in,out] _root The json root to fill with the data.
	* @param _loc_data The localisation data to use.
	**/
	void FileManager::_write_languages( Json::Value& _root, const fzn::Localisation::LocalisationData& _loc_data ) const
	{
		// "available_languages" : ["english","french","spanish"],

		for( uint32_t language_id{ 0 }; language_id < _loc_data.m_languages.size(); ++language_id )
		{
			_root[ "available_languages" ][ language_id ] = _loc_data.m_languages[ language_id ].c_str();
		}
	}

	/**
	* @brief Write the entries section of the given localisation data in the given json root.
	* @param [in,out] _root The json root to fill with the data.
	* @param _loc_data The localisation data to use.
	**/
	void FileManager::_write_entries( Json::Value& _root, const fzn::Localisation::LocalisationData& _loc_data ) const
	{
		/*{
			"name" : "yes",
			"translations":
			[
				["english","yes"],
				["french","oui"],
				["spanish","si"]
			]
		},*/

		for( uint32_t entry_index{ 0 }; entry_index < _loc_data.m_entries.size(); ++entry_index )
		{
			const fzn::Localisation::Entry& entry{ _loc_data.m_entries[ entry_index ] };
			Json::Value json_entry{};

			json_entry[ "name" ] = entry.m_name.c_str();

			uint32_t translation_id{ 0 };
			for( uint32_t language_id{ 0 }; language_id < entry.m_translations.size(); ++language_id )
			{
				const std::string& translation{ entry.m_translations[ language_id ] };

				if( translation.empty() )
					continue;

				json_entry[ "translations" ][ translation_id ][ 0 ] = _loc_data.m_languages[ language_id ].c_str();
				json_entry[ "translations" ][ translation_id ][ 1 ] = translation.c_str();
				++translation_id;
			}

			_root[ "entries" ][ entry_index ] = json_entry;
		}
	}

	/**
	* @brief Close the current entries file, clearing all entries and the path to their file.
	* @param [out] _loc_data The localisation data to be cleared.
	**/
	void FileManager::_close_entries( fzn::Localisation::LocalisationData& _loc_data )
	{
		_loc_data.clear();
		m_project.m_entries_path.clear();
	}


	/************************************************************************
	* ENUM FILE
	************************************************************************/

	/**
	* @brief Generate the enum file using the given localisation data to the previously selected path.
	* @param [out] _loc_data The localisation data to be used.
	**/
	void FileManager::_generate_enum_file( fzn::Localisation::LocalisationData& _loc_data ) const
	{
		if( m_project.m_enum_file_path.empty() || _loc_data.m_entries.empty() )
			return;

		std::ofstream output( m_project.m_enum_file_path );

		output << "#pragma once\n\n" << enum_file_message << "\n\nenum class LocID\n{\n";

		for( const fzn::Localisation::Entry& entry : _loc_data.m_entries )
		{
			output << "\t" << entry.m_name << ",";

			if( entry.m_translations.front().empty() == false )
				output << "\t\t// " << entry.m_translations.front() << std::endl;
			else
				output << std::endl;
		}

		output << "\tCOUNT\n};\n";

		output.close();
	}

	/**
	* @brief Show a fave ile dialog to select where to generate the enum file using the given localisation data.
	* @param [out] _loc_data The localisation data to be used.
	**/
	void FileManager::_generate_enum_file_as( fzn::Localisation::LocalisationData& _loc_data )
	{
		std::string new_path = fzn::Tools::save_file_as( "(*.h) Header File\0*.h\0"
			"(*.*) All files \0*.*\0",
			".h" );

		if( new_path.empty() )
			return;

		m_project.m_enum_file_path = new_path;
		_generate_enum_file( _loc_data );
	}

	/**
	* @brief Show an open file dialog to select the project file and load the corresponding entries file to fill the given localisation data with it.
	* @param [out] _loc_data The localisation data to be filled.
	**/
	void FileManager::_open_project_file( fzn::Localisation::LocalisationData& _loc_data )
	{
		m_project.m_project_path = fzn::Tools::open_file( "(*.trproj) TranslatR Project\0*.trproj\0"
			"(*.*) All files \0*.*\0" );

		auto file = std::ifstream{ m_project.m_project_path };

		if( file.is_open() == false )
			return;

		auto root = Json::Value{};

		file >> root;

		m_project.m_entries_path = root[ "entries_path" ].asString();
		m_project.m_enum_file_path = root[ "enum_file_path" ].asString();

		fzn::Localisation::Manager::load_entries( m_project.m_entries_path, _loc_data );
	}

	/**
	* @brief Save the current project to the previously selected path.
	**/
	void FileManager::_save_project() const
	{
		if( m_project.m_project_path.empty() )
			return;

		auto file = std::ofstream{ m_project.m_project_path };
		auto root = Json::Value{};
		Json::StreamWriterBuilder writer_builder;

		writer_builder.settings_[ "emitUTF8" ] = true;
		std::unique_ptr<Json::StreamWriter> writer( writer_builder.newStreamWriter() );

		root[ "entries_path" ] = m_project.m_entries_path.c_str();
		root[ "enum_file_path" ] = m_project.m_enum_file_path.c_str();

		writer->write( root, &file );
	}

	/**
	* @brief Show a save file dialog to select where to save the current project.
	**/
	void FileManager::_save_project_as()
	{
		std::string new_path = fzn::Tools::save_file_as( "(*.trproj) TranslatR Project\0*.trproj\0"
			"(*.*) All files \0*.*\0",
			".trproj" );

		if( new_path.empty() )
			return;

		m_project.m_project_path = new_path;
		_save_project();
	}

	/************************************************************************
	* PROJECT
	************************************************************************/

	/**
	* @brief Close the current project, clearing all save paths.
	* @param [out] _loc_data The localisation data to be cleared.
	**/
	void FileManager::_close_project( fzn::Localisation::LocalisationData& _loc_data )
	{
		m_project.clear();
		_loc_data.clear();
	}
}
