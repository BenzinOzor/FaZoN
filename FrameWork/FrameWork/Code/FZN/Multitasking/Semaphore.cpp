//------------------------------------------------------------------------
//Author : Philippe OFFERMANN
//Date : 28.10.14
//Description : Custom semaphore class
//------------------------------------------------------------------------

#include "FZN/Includes.h"
#include "FZN/Multitasking/Semaphore.h"


namespace fzn
{
	/////////////////CONSTRUCTORS / DESTRUCTORS/////////////////

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Default constructor
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	Semaphore::Semaphore()
	{
		m_semaphore = CreateSemaphoreA( nullptr, 1, 1, nullptr );
		m_ticket = 1;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Parametered constructor
	//Parameter 1 : Initial ticket count
	//Parameter 2 : Maximum ticket count
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	Semaphore::Semaphore( LONG initCount, LONG maxCount )
	{
		m_semaphore = CreateSemaphoreA( nullptr, initCount, maxCount, nullptr );
		m_ticket = initCount;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Destructor
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	Semaphore::~Semaphore()
	{
		CloseHandle( m_semaphore );
	}


	/////////////////LOCK MANAGEMENT/////////////////

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Locks the semaphore
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	DWORD Semaphore::Lock()
	{
		DWORD lockResult = WaitForSingleObject( m_semaphore, INFINITE );

		if( lockResult == WAIT_OBJECT_0 )
			m_ticket--;

		return lockResult;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Locks the semaphore
	//Parameter : Time to wait
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	DWORD Semaphore::Lock( DWORD _time )
	{
		DWORD lockResult = WaitForSingleObject( m_semaphore, _time );

		if( lockResult == WAIT_OBJECT_0 )
			m_ticket--;

		return lockResult;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Unlocks the semaphore
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	INT8 Semaphore::Unlock()
	{
		INT8 releaseResult = ReleaseSemaphore( m_semaphore, 1, nullptr );

		if( releaseResult )
			m_ticket++;

		return releaseResult;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Unlocks the semaphore
	//Parameter : Number of tickets to give back to the semaphore
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------
	INT8 Semaphore::Unlock( LONG releaseCount )
	{
		INT8 releaseResult = ReleaseSemaphore( m_semaphore, releaseCount, nullptr );

		if( releaseResult )
			m_ticket++;

		return releaseResult;
	}
} //namespace fzn
