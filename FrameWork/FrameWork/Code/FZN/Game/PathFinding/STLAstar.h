/*
AStarSearch class
Copyright 2001 Justin Heyes-Jones
*/

//=========================================================
//========================!CAUTION!==========================
//=========================================================

//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Methods that need to be overloaded in the custom class so the Astar can work
//------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*==========================================================================================

float GoalDistanceEstimate( UserState& nodeGoal );											//Estimated distance between a given node and the goal
INT8 IsGoal( UserState& nodeGoal );															//Checks if the given node is the goal one
INT8 GetSuccessors( AStarSearch<UserState>* astarsearch, UserState* parent_node );			//Generates successors to the given node
float GetCost( UserState& successor );															//Calculus of the cost of moving from the curent node to one of its successor
INT8 IsSameState( UserState& rhs );															//Comparison between a given node and the current

==========================================================================================*/


#ifndef _STLASTAR_H_
#define _STLASTAR_H_


#include "FZN/DataStructure/FixedSizeAllocator.h"

// Fixed size memory allocator can be disabled to compare performance
// Uses std new and delete instead if you turn it off
#define USE_FSA 1

// disable warning that debugging information has lines that are truncated
// occurs in stl headers
//#pragma warning( disable : 4786 )

namespace fzn
{
	//UserState is the users state space type
	template <class UserState> class AStarSearch
	{
	public:
		/////////////////DATA/////////////////

		enum SEARCH_STATE
		{
			SEARCH_STATE_NOT_INITIALISED,
			SEARCH_STATE_SEARCHING,
			SEARCH_STATE_SUCCEEDED,
			SEARCH_STATE_FAILED,
			SEARCH_STATE_OUT_OF_MEMORY,
			SEARCH_STATE_INVALID
		};


		//=========================================================
		//==========================NODE===========================
		//=========================================================

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//A node represents a possible state in the search. The user provided state type is included inside this type
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		class Node
		{
		public:
			//------------------------------------------------------------------------------------------------------------------------------------------------------------------
			//Constructor
			//------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Node() : parent( 0 ), child( 0 ), g( 0.0f ), h( 0.0f ), f( 0.0f ) {}


			/////////////////MEMBER VARIABLES/////////////////

			Node* parent;				// used during the search to record the parent of successor nodes
			Node* child;					// used after the search for the application to view the search in reverse

			float g;							// cost of this node + it's predecessors
			float h;							// heuristic estimate of distance to goal
			float f;							// sum of cumulative cost of predecessors and self and heuristic

			UserState m_UserState;
		};


		//=========================================================
		//======================HEAPCOMPARE_F=======================
		//=========================================================

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//For sorting the heap the STL needs compare function that lets us compare the f value of two nodes
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		class HeapCompare_f
		{
		public:
			//------------------------------------------------------------------------------------------------------------------------------------------------------------------
			//Compares the f value of two nodes
			//------------------------------------------------------------------------------------------------------------------------------------------------------------------
			INT8 operator() ( const Node *x, const Node *y ) const
			{
				return x->f > y->f;
			}
		};


		/////////////////METHODS/////////////////

		/////////////////CONSTRUCTOR / DESTRUCTOR/////////////////

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Constructor
		//Parameter : Maximum number of nodes
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		AStarSearch( int _maxNodes = 1000 );


		/////////////////OTHER FUNCTIONS/////////////////

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Call at any time to cancel the search and free up all the memory
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		void SetReopenClosed( INT8 _reopen );
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Call at any time to cancel the search and free up all the memory
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		void CancelSearch();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Setting of the start and goal states
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		void SetStartAndGoalStates( UserState& _start, UserState& _goal );
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Accessor on the start and goal states
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		void GetStartAndGoalStates( UserState& _start, UserState& _goal );
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Advances search one step
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UINT SearchStep();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//User calls this to add a successor to a list of successors when expanding the search frontier
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		INT8 AddSuccessor( UserState& _state );
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Free the solution nodes
		//This is done to clean up all used Node memory when you are done with the search
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		void FreeSolutionNodes();


		/////////////////SOLUTION TRAVERSING FUNCTIONS/////////////////

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Accesor on the distance to the goal
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		float GetSolutionDistance();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get start node
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetSolutionStart();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get end node
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetSolutionEnd();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get next node
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetSolutionNext();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Step solution iterator backwards
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetSolutionPrev();

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//For educational use and debugging it is useful to be able to view
		//the open and closed list at each step, here are two functions to allow that.
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get start node in the open list
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetOpenListStart();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get start node in the open list
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetOpenListStart( float& f, float& g, float& h );
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get next node in the open list
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetOpenListNext();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get next node in the open list
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetOpenListNext( float& f, float& g, float& h );
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get start node in the closed list
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetClosedListStart();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get start node in the closed list
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetClosedListStart( float& f, float& g, float& h );
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get next node in the closed list
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetClosedListNext();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get next node in the closed list
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		UserState* GetClosedListNext( float& f, float& g, float& h );

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get the number of steps
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		int GetStepCount();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Get the number of nodes in the solution
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		int GetNumberOfNodes();

	private:
		/////////////////METHODS/////////////////

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//This is called when a search fails or is cancelled to free all used memory 
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		void FreeAllNodes();
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//This call is made by the search class when the search ends. A lot of nodes may be
		//created that are still present when the search ends. They will be deleted by this routine once the search ends
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		void FreeUnusedNodes();

		/////////////////NODE MEMORY MANAGEMENT/////////////////

		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Allocation of a new node
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Node* AllocateNode()
		{
#if !USE_FSA
			Node* p = new Node;
			return p;
#else
			Node* address = m_FixedSizeAllocator.Alloc();

			if( !address )
			{
				return nullptr;
			}
			m_AllocateNodeCount++;
			Node* p = new ( address )Node;
			return p;
#endif
		}
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Free a node
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------
		void FreeNode( Node *node );

		/////////////////MEMBER VARIABLES/////////////////

		std::vector<Node*> m_OpenList;								// Heap (simple vector but used as a heap, cf. Steve Rabin's game gems article)
		std::vector<Node*> m_ClosedList;							// Closed list is a vector.
		std::vector<Node*> m_Successors;							// Successors is a vector filled out by the user each type successors to a node are generated

		UINT m_State;															// State
		int m_Steps;																// Counts steps
		INT8 m_CancelRequest;

		Node* m_Start;															// Start state pointers
		Node* m_Goal;															//goal state pointers

		Node* m_CurrentSolutionNode;

		FixedSizeAllocator<Node> m_FixedSizeAllocator;		// Memory

		/////////////////DEBUG/////////////////
		//Need to keep these two iterators around for the user Dbg functions

		typename std::vector<Node*>::iterator iterDbgOpen;
		typename std::vector<Node*>::iterator iterDbgClosed;

		//Count memory allocation and free's

		int m_AllocateNodeCount;
		int m_FreeNodeCount;
		INT8 m_bReopenClosed;

		int m_nodesNumber;
	};
} //namespace fzn

#include "FZN/Game/PathFinding/STLAstar.inl"

#endif //_STLASTAR_H_